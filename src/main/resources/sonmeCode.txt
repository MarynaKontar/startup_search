
 <c:forEach items="${command.businessPlan}" var="businessPlan">
                     <form:input path="businessPlan" type="number" name="${businessPlan.id}" value="${businessPlan.id}" hidden="true"/>
                 </c:forEach>




 <c:forEach items="${command.businessPlan}" var="businessPlan">

                        <tr align="center">
                            <th>Idea</th>
                            <td>
                                <form:input path="businessPlan.idea" type="text" name="businessPlan.idea" value="${businessPlan.idea}"/>
                            </td>
                        </tr>

                        <tr align="center">
                            <th>Current state</th>
                            <td>
                                <form:input path="businessPlan.currentState" type="text" name="businessPlan.currentState" value="${businessPlan.currentState}"/>
                            </td>
                        </tr>

                        <tr align="center">
                            <th>Market</th>
                            <td>
                                <form:input path="businessPlan.market" type="text" name="businessPlan.market" value="${businessPlan.market}"/>
                            </td>
                        </tr>


                    </c:forEach>


Caused by: org.hibernate.loader.MultipleBagFetchException: cannot simultaneously fetch multiple bags: [ua.goit.entity.User.roles, ua.goit.entity.User.experiences]

org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'mainController': Invocation of init method failed; nested exception is org.springframework.orm.jpa.JpaSystemException: A collection with cascade="all-delete-orphan" was no longer referenced by the owning entity instance: ua.goit.entity.User.experiences; nested exception is org.hibernate.HibernateException: A collection with cascade="all-delete-orphan" was no longer referenced by the owning entity instance: ua.goit.entity.User.experiences







<script>
                function showError(container, errorMessage) {
                    container.className = 'error';
                    var msgElem = document.createElement('span');
                    msgElem.className = "error-message";
                    msgElem.innerHTML = errorMessage;
                    container.appendChild(msgElem);
                }

                function resetError(container) {
                    container.className = '';
                    if (container.lastChild.className == "error-message") {
                        container.removeChild(container.lastChild);
                    }
                }

                function validate(form) {
                    var elems = form.elements;
                    <%--var usernames = ${usernames};--%>

                    resetError(elems.username.parentNode);
                    if (!elems.username.value) {
                        showError(elems.username.parentNode, ' Enter login.');
                    }
//                    resetError(elems.username.parentNode);
//                    if (usernames.contains(elems.username.value)) {
//                        showError(elems.username.parentNode, ' This login already exists.');
//                    }
                    resetError(elems.password.parentNode);
                    if (!elems.password.value) {
                        showError(elems.password.parentNode, ' Enter password.');
                    } else if (elems.password.value != elems.password2.value) {
                        showError(elems.password.parentNode, ' Passwords are not equals.');
                    }
                    resetError(elems.password2.parentNode);
                    if (!elems.password2.value) {
                        showError(elems.password2.parentNode, ' Repeat password.');
                    }
                    resetError(elems.email.parentNode);
                    if (!elems.email.value) {
                        showError(elems.email.parentNode, ' Enter email.');
                    }
                }
            </script>










   RegistrationController
              //TODO в чем разница между двумя способами для @PostMapping("registration/") - через @ModelAttribute и @RequestParam? Какой лучше?
            //    /**
            //     * Mapping for url ":/registration/"
            //     * Saves {@link User} to database
            //     * @param login    login from the form
            //     * @param password password from the form
            //     * @param email    email from the form
            //     * @return redirect link to login page
            //     */
            //    @PostMapping("registration/")
            //    public String registration(@RequestParam String login, @RequestParam String password, @RequestParam String email) {
            //        User user = new User();
            //        user.setUsername(login);
            //        user.setPassword(passwordEncoder.encode(password));
            //        user.getContact().setEmail(email);
            //        userService.save(user);
            //        LOGGER.info("User " + user + " saved to database. Redirecting to login page after registration");
            //        return "redirect:/login";
            //    }